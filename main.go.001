package main

import (
        "crypto/tls"
        "crypto/x509"
        "flag"
        "fmt"
        "net"
        "os"
        "strings"
        "time"
)

func main() {
        url := flag.String("url", "", "URL to test (e.g., https://example.com, imaps://mail.example.com:993)")
        timeout := flag.Duration("timeout", 10*time.Second, "Timeout for connection")
        retries := flag.Int("retries", 3, "Number of retries")
        proto := flag.String("proto", "", "Specific protocol to use (e.g., TLS1.2)")
        cipher := flag.String("cipher", "", "Specific cipher suite to use (e.g., TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256)")

        flag.Parse()

        if *url == "" {
                fmt.Println("Usage: ssltester -url <URL> [-timeout <duration>] [-retries <number>] [-proto <protocol>] [-cipher <cipher>]")
                os.Exit(1)
        }

        for i := 0; i <= *retries; i++ {
                certInfo, err := testSSL(*url, *timeout, *proto, *cipher)
                if err == nil {
                        fmt.Println("SSL Test Successful:")
                        fmt.Println("  URL:", *url)
                        fmt.Println("  Protocol:", certInfo.Protocol)
                        fmt.Println("  Cipher:", certInfo.Cipher)
                        fmt.Println("  Certificate:")
                        fmt.Println("    Subject:", certInfo.Certificate.Subject)
                        fmt.Println("    Issuer:", certInfo.Certificate.Issuer)
                        fmt.Println("    Valid From:", certInfo.Certificate.NotBefore)
                        fmt.Println("    Valid To:", certInfo.Certificate.NotAfter)
                        fmt.Println("    SANs:", certInfo.Certificate.DNSNames)
                        os.Exit(0)
                }
                fmt.Printf("Attempt %d failed: %v\n", i+1, err)
                if i < *retries {
                        time.Sleep(1 * time.Second) // Wait before retrying
                }
        }

        fmt.Println("SSL Test Failed after multiple retries.")
        os.Exit(1)
}

type CertInfo struct {
        Certificate *x509.Certificate
        Protocol    string
        Cipher      string
}

func testSSL(url string, timeout time.Duration, proto string, cipher string) (*CertInfo, error) {
        u := strings.SplitN(url, "://", 2)
        if len(u) != 2 {
                return nil, fmt.Errorf("invalid URL format")
        }
        scheme := u[0]
        hostPort := u[1]

        if !strings.Contains(hostPort, ":") {
                switch scheme {
                case "https":
                        hostPort += ":443"
                case "imaps":
                        hostPort += ":993"
                case "pops":
                        hostPort += ":995"
                case "ldaps":
                        hostPort += ":636"
                case "smtps":
                        hostPort += ":465"
                case "starttls":
                        hostPort += ":587"
                default:
                        return nil, fmt.Errorf("unknown scheme and no port specified")
                }
        }

        dialer := net.Dialer{Timeout: timeout}
        conn, err := dialer.Dial("tcp", hostPort)
        if err != nil {
                return nil, fmt.Errorf("connection error: %w", err)
        }
        defer conn.Close()

        tlsConfig := &tls.Config{
                InsecureSkipVerify: true, // Set to true to skip verification
        }

        if proto != "" {
                switch proto {
                case "TLS1.0": tlsConfig.MinVersion = tls.VersionTLS10; tlsConfig.MaxVersion = tls.VersionTLS10
                case "TLS1.1": tlsConfig.MinVersion = tls.VersionTLS11; tlsConfig.MaxVersion = tls.VersionTLS11
                case "TLS1.2": tlsConfig.MinVersion = tls.VersionTLS12; tlsConfig.MaxVersion = tls.VersionTLS12
                case "TLS1.3": tlsConfig.MinVersion = tls.VersionTLS13; tlsConfig.MaxVersion = tls.VersionTLS13
                default: return nil, fmt.Errorf("unsupported protocol: %s", proto)
                }

        }

        if cipher != "" {
                cipherSuiteMap := make(map[string]uint16)
                for _, suite := range tls.CipherSuites() {
                        cipherSuiteMap[suite.Name] = suite.ID
                }
        
                if cipherID, ok := cipherSuiteMap[cipher]; ok {
                        tlsConfig.CipherSuites = []uint16{cipherID}
                } else {
                        return nil, fmt.Errorf("unsupported cipher suite: %s", cipher)
                }
        }

        tlsConn := tls.Client(conn, tlsConfig)
        defer tlsConn.Close()

        err = tlsConn.Handshake()
        if err != nil {
                return nil, fmt.Errorf("TLS handshake error: %w", err)
        }

        cert := tlsConn.ConnectionState().PeerCertificates[0]

        protocolVersion := tlsConn.ConnectionState().Version
        protocolString := ""
        switch protocolVersion {
        case tls.VersionTLS10: protocolString = "TLS 1.0"
        case tls.VersionTLS11: protocolString = "TLS 1.1"
        case tls.VersionTLS12: protocolString = "TLS 1.2"
        case tls.VersionTLS13: protocolString = "TLS 1.3"
        default: protocolString = fmt.Sprintf("Unknown TLS version %d", protocolVersion)
        }

        cipherSuite := tlsConn.ConnectionState().CipherSuite
        cipherString := ""
        for _, suite := range tls.CipherSuites() {
                if suite.ID == cipherSuite {
                        cipherString = suite.Name
                        break
                }
        }

        return &CertInfo{
                Certificate: cert,
                Protocol:    protocolString,
                Cipher:      cipherString,
        }, nil
}
