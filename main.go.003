package main

import (
        "crypto/tls"
        "crypto/x509"
        "flag"
        "fmt"
        "net"
        "os"
        "time"
)

func main() {
        hostport := flag.String("hostport", "", "Hostname:port to test (required)")
        timeout := flag.Duration("timeout", 10*time.Second, "Connection timeout")
        retries := flag.Int("retries", 3, "Number of connection retries")
        tlsVersion := flag.String("tls", "", "Specific TLS version (e.g., TLS1.2, TLS1.3)")
        cipherSuite := flag.String("cipher", "", "Specific cipher suite (e.g., TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384)")
        keystore := flag.String("keystore", "", "Path to trusted keystore (optional)")
        insecure := flag.Bool("insecure", false, "Bypass chain of trust verification (use with caution)")

        flag.Parse()

        if *hostport == "" {
                fmt.Println("Error: --hostport is required")
                flag.Usage()
                os.Exit(1)
        }

        var tlsConfig *tls.Config

        if *keystore != "" {
                certs, err := loadCertificates(*keystore)
                if err != nil {
                        fmt.Println("Error loading keystore:", err)
                        os.Exit(1)
                }
        
                tlsConfig = &tls.Config{
                        RootCAs: certs,
                        InsecureSkipVerify: *insecure,
                }
        } else {
                tlsConfig = &tls.Config{
                        InsecureSkipVerify: *insecure, // Only set if explicitly requested
                }
        }


        if *tlsVersion != "" {
                switch *tlsVersion {
                case "TLS1.0":
                        tlsConfig.MinVersion = tls.VersionTLS10
                        tlsConfig.MaxVersion = tls.VersionTLS10
                case "TLS1.1":
                        tlsConfig.MinVersion = tls.VersionTLS11
                        tlsConfig.MaxVersion = tls.VersionTLS11
                case "TLS1.2":
                        tlsConfig.MinVersion = tls.VersionTLS12
                        tlsConfig.MaxVersion = tls.VersionTLS12
                case "TLS1.3":
                        tlsConfig.MinVersion = tls.VersionTLS13
                        tlsConfig.MaxVersion = tls.VersionTLS13
                default:
                        fmt.Println("Error: Invalid TLS version")
                        os.Exit(1)
                }
        }

        if *cipherSuite != "" {
                tlsConfig.CipherSuites = []uint16{getCipherSuite(*cipherSuite)}
                if tlsConfig.CipherSuites[0] == 0 {
                        fmt.Println("Error: Invalid cipher suite")
                        os.Exit(1)
                }
        }

        for i := 0; i < *retries; i++ {
                conn, err := net.DialTimeout("tcp", *hostport, *timeout)
                if err != nil {
                        fmt.Printf("Connection attempt %d failed: %v\n", i+1, err)
                        time.Sleep(time.Second) // Wait before retrying
                        continue // Retry the loop
                }
                defer conn.Close()

                tlsConn := tls.Client(conn, tlsConfig)
                err = tlsConn.Handshake()

                if err != nil {
                        fmt.Printf("TLS handshake failed: %v\n", err)
                        os.Exit(1)
                }

                cert := tlsConn.ConnectionState().PeerCertificates[0]

                fmt.Println("Certificate Information:")
                fmt.Println("  Subject:", cert.Subject)
                fmt.Println("  SAN:", cert.DNSNames)
                fmt.Println("  Protocol:", tlsConn.ConnectionState().NegotiatedProtocol)
                fmt.Println("  Cipher Suite:", tls.CipherSuiteName(tlsConn.ConnectionState().CipherSuite))

                // Verify the chain (if not insecure)
                if !*insecure {
                        roots := x509.NewCertPool()
                        if *keystore != "" {
                                roots = tlsConfig.RootCAs
                        } else {
                                roots, err = x509.SystemCertPool()
                                if err != nil {
                                        fmt.Println("Error loading system root CAs:", err)
                                        os.Exit(1)
                                }
                        }

                        opts := x509.VerifyOptions{
                                Roots:         roots,
                                Intermediates: x509.NewCertPool(), // You might need to populate this
                        }

                        _, err = cert.Verify(opts)
                        if err != nil {
                                fmt.Println("  Chain Verification Error:", err)
                        } else {
                                fmt.Println("  Chain Verification: Success")
                        }

                } else {
                        fmt.Println("  Chain Verification: Skipped (insecure mode)")
                }

                fmt.Println("  Issuer:", cert.Issuer)
                fmt.Println("  Not Before:", cert.NotBefore)
                fmt.Println("  Not After:", cert.NotAfter)

                return // Success, exit after the first successful connection
        }

        fmt.Println("Connection failed after multiple retries.")
        os.Exit(1)
}

func loadCertificates(keystorePath string) (*x509.CertPool, error) {
        certs, err := os.ReadFile(keystorePath)
        if err != nil {
                return nil, err
        }

        certPool := x509.NewCertPool()
        if ok := certPool.AppendCertsFromPEM(certs); !ok {
                return nil, fmt.Errorf("failed to parse root certificate")
        }
        return certPool, nil
}

func getCipherSuite(cipher string) uint16 {
        // Use tls.CipherSuites() to get the actual cipher suite ID.
        for _, suite := range tls.CipherSuites() {
                if tls.CipherSuiteName(suite) == cipher {
                        return suite
                }
        }
        return 0
}

