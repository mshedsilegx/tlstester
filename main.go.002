package main

import (
        "crypto/tls"
        "crypto/x509"
        "flag"
        "fmt"
        "net"
        "os"
        "strings"
        "time"
)

func main() {
        url := flag.String("url", "", "URL to test (e.g., https://example.com:443, pop3s://example.com:995, tcps://example.com:25, etc.)")
        timeout := flag.Duration("timeout", 10*time.Second, "Timeout for connection")
        retries := flag.Int("retries", 3, "Number of retries")
        protocol := flag.String("protocol", "", "Specific protocol to use (e.g., TLS1.2, TLS1.3)")
        cipher := flag.String("cipher", "", "Specific cipher suite to use (e.g., TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256)")
        keystore := flag.String("keystore", "", "Path to trusted keystore (PEM format)")
        insecure := flag.Bool("insecure", false, "Bypass chain of trust verification (use with caution)")

        flag.Parse()

        if *url == "" {
                fmt.Println("Usage: ssltester -url <URL> [options]")
                flag.PrintDefaults()
                os.Exit(1)
        }

        var roots *x509.CertPool
        if *keystore != "" {
                certs, err := os.ReadFile(*keystore)
                if err != nil {
                        fmt.Printf("Error reading keystore: %v\n", err)
                        os.Exit(1)
                }
                roots = x509.NewCertPool()
                ok := roots.Append(certs)
                if !ok {
                        fmt.Println("Failed to parse root certificate(s) in keystore.")
                        os.Exit(1)
                }
        } else {
                roots, err := x509.SystemCertPool()
                if err != nil {
                        fmt.Println("Error loading system root CAs:", err)
                        os.Exit(1)
                }
        }

        for i := 0; i <= *retries; i++ {
                conn, err := testConnection(*url, *timeout, roots, *insecure, *protocol, *cipher)
                if err == nil {
                        cert := conn.ConnectionState().PeerCertificates[0]
                        fmt.Println("Certificate Information:")
                        fmt.Println("  Subject:", cert.Subject)
                        fmt.Println("  Issuer:", cert.Issuer)
                        fmt.Println("  Valid From:", cert.NotBefore)
                        fmt.Println("  Valid To:", cert.NotAfter)
                        fmt.Println("  SANs:", cert.DNSNames)
                        fmt.Println("  Protocol:", conn.ConnectionState().NegotiatedProtocol)
                        fmt.Println("  Cipher Suite:", tls.CipherSuiteName(conn.ConnectionState().CipherSuite)) // Use CipherSuiteName
                        conn.Close()
                        return
                }
                fmt.Printf("Connection attempt %d failed: %v\n", i+1, err)
                if i < *retries {
                        time.Sleep(1 * time.Second)
                }
        }

        fmt.Println("Connection failed after multiple retries.")
        os.Exit(1)
}

func testConnection(url string, timeout time.Duration, roots *x509.CertPool, insecure bool, protocol, cipher string) (*tls.Conn, error) {
        u := strings.SplitN(url, "://", 2)
        if len(u) != 2 {
                return nil, fmt.Errorf("invalid URL format")
        }
        scheme := u[0]
        address := u[1]

        if !strings.Contains(address, ":") {

                switch scheme {
                case "https":
                        hostPort += ":443"
                case "imaps":
                        hostPort += ":993"
                case "pops":
                        hostPort += ":995"
                case "ldaps":
                        hostPort += ":636"
                case "smtps":
                        hostPort += ":465"
                case "starttls":
                        hostPort += ":587"
                default:
                        return nil, fmt.Errorf("unknown scheme and no port specified")
                }
        }

        dialer := net.Dialer{Timeout: timeout}
        conn, err := dialer.Dial("tcp", address)
        if err != nil {
                return nil, err
        }
        defer conn.Close()

        tlsConfig := &tls.Config{
                RootCAs:            roots,
                InsecureSkipVerify: insecure,
        }

        if protocol != "" {
                version, ok := getTLSVersion(protocol)
                if !ok {
                        return nil, fmt.Errorf("unsupported protocol: %s", protocol)
                }
                tlsConfig.MinVersion = version
                tlsConfig.MaxVersion = version
        }

        if cipher != "" {
                suite := getCipherSuite(cipher)
                if suite == 0 {
                        return nil, fmt.Errorf("unsupported cipher suite: %s", cipher)
                }
                tlsConfig.CipherSuites = []uint16{suite}
        }

        var tlsConn *tls.Conn

        switch scheme {
        case "https", "pop3s", "imaps", "ldaps", "tcps":
                tlsConfig.ServerName = strings.Split(address, ":")[0]
                tlsConn = tls.Client(conn, tlsConfig)
                err = tlsConn.Handshake()
                if err != nil {
                        return nil, err
                }
        default: // Try StartTLS
                tlsConn = tls.Client(conn, tlsConfig)
                err = tlsConn.Handshake()
                if err != nil {
                        return nil, err
                }
        }

        return tlsConn, nil
}

func getTLSVersion(version string) (uint16, bool) {
        switch version {
        case "TLS1.0":
                return tls.VersionTLS10, true
        case "TLS1.1":
                return tls.VersionTLS11, true
        case "TLS1.2":
                return tls.VersionTLS12, true
        case "TLS1.3":
                return tls.VersionTLS13, true
        default:
                return 0, false
        }
}

func getCipherSuite(cipher string) uint16 {
        // Use tls.CipherSuites() to get the actual cipher suite ID.
        for _, suite := range tls.CipherSuites() {
                if tls.CipherSuiteName(suite) == cipher {
                        return suite
                }
        }
        return 0
}
